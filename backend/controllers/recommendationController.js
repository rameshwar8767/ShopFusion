// controllers/recommendationController.js

const Transaction = require("../models/Transaction");

const AssociationRule = require("../models/AssociationRule");
const axios = require("axios");
/**
 * =====================================================
 * @desc    Get Hybrid Product Recommendations
 * @route   GET /api/recommendations/hybrid
 * @access  Private (Retailer)
 * =====================================================
 *
 * Output is SIMPLE and RETAILER FRIENDLY:
 * - productId
 * - productName
 * - reason (why recommended)
 */
exports.getHybridRecommendations = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const limit = Number(req.query.limit || 10);

    // 1Ô∏è‚É£ Fetch MBA rules (already generated by Python ML)
    const rules = await AssociationRule.find({ userId })
      .sort({ lift: -1 })
      .limit(100);

    if (rules.length === 0) {
      return res.json({
        success: true,
        message: "No recommendations available. Run ML engine first.",
        data: [],
      });
    }

    // 2Ô∏è‚É£ Fetch all products of retailer
    const products = await Product.find({ user: userId });

    const productMap = {};
    products.forEach((p) => {
      productMap[p.name] = p;
    });

    const recommendations = [];

    // 3Ô∏è‚É£ Build retailer-friendly recommendations
    for (const rule of rules) {
      const from = rule.antecedent[0];
      const to = rule.consequent[0];

      const fromProduct = productMap[from];
      const toProduct = productMap[to];

      if (!fromProduct || !toProduct) continue;

      // 4Ô∏è‚É£ Expiry-aware logic (Step 3 support)
      let urgency = "Normal Sale";
      if (toProduct.expiryDate) {
        const daysLeft =
          (new Date(toProduct.expiryDate) - new Date()) /
          (1000 * 60 * 60 * 24);

        if (daysLeft <= 0) urgency = "Expired ‚Äì Remove from stock";
        else if (daysLeft <= 3) urgency = "Urgent Sale (Near Expiry)";
        else if (daysLeft <= 7) urgency = "Sell Soon";
      }

      recommendations.push({
        buyWith: {
          productId: fromProduct.productId,
          productName: fromProduct.name,
        },
        recommend: {
          productId: toProduct.productId,
          productName: toProduct.name,
        },
        metrics: {
          lift: rule.lift.toFixed(2),
          confidence: rule.confidence.toFixed(2),
          support: rule.support.toFixed(2),
        },
        reason: `Frequently bought together (${urgency})`,
      });

      if (recommendations.length >= limit) break;
    }

    return res.json({
      success: true,
      count: recommendations.length,
      data: recommendations,
    });
  } catch (err) {
    next(err);
  }
};

// exports.getDashboard = async (req, res, next) => {
//   try {
//     const userId = req.user.id;

//     const rules = await AssociationRule.find({ userId })
//       .sort({ lift: -1 })
//       .limit(20);

//     const bundles = rules.map((rule) => ({
//       products: [...rule.antecedent, ...rule.consequent],
//       confidence: rule.confidence,
//       lift: rule.lift,
//       expectedUplift: "High",
//     }));

//     return res.json({
//       success: true,
//       data: {
//         bundles,
//       },
//     });
//   } catch (err) {
//     next(err);
//   }
// };
// controllers/recommendationController.js



exports.getDashboard = async (req, res, next) => {
  try {
    const userId = req.user.id;

    const rules = await AssociationRule.find({ userId })
      .sort({ lift: -1 })
      .limit(20)
      .lean();

    if (!rules.length) {
      return res.json({
        success: true,
        data: { bundles: [] },
      });
    }

    const products = await Product.find({ user: userId }).lean();
    const productMap = {};
    products.forEach((p) => {
      productMap[p.productId] = p;
    });

    const bundles = rules.map((rule) => {
      const productIds = [...rule.antecedent, ...rule.consequent];

      const items = productIds.map((pid) => {
        const p = productMap[pid];
        return {
          productId: pid,
          name: p?.name || pid,
          expiryDate: p?.expiryDate || null,
          status: p?.status || "ACTIVE",
        };
      });

      // Compute near expiry from expiryDate (e.g., within next 7 days)
      const hasNearExpiry = items.some((it) => {
        if (!it.expiryDate) return false;
        const daysLeft =
          (new Date(it.expiryDate) - new Date()) / (1000 * 60 * 60 * 24);
        return daysLeft > 0 && daysLeft <= 7;
      });

      return {
        products: items,
        confidence: rule.confidence,
        lift: rule.lift,
        support: rule.support,
        expectedUplift: "High",
        metadata: {
          nearExpiryInBundle: hasNearExpiry,
        },
      };
    });

    res.json({
      success: true,
      data: { bundles },
    });
  } catch (err) {
    next(err);
  }
};


/**
 * =====================================================
 * @desc    Get Raw Association Rules (optional table view)
 * @route   GET /api/recommendations/rules
 * =====================================================
 */
exports.getAssociationRules = async (req, res, next) => {
  try {
    const rules = await AssociationRule.find({ userId: req.user.id })
      .sort({ lift: -1 })
      .limit(50);

    res.json({
      success: true,
      count: rules.length,
      data: rules,
    });
  } catch (err) {
    next(err);
  }
};



// exports.getProductBundles = async (req, res, next) => {
//   try {
//     const userId = req.user.id;
//     const limit = Number(req.query.limit || 20);

//     const rules = await AssociationRule.find({ userId })
//       .sort({ lift: -1 })
//       .limit(limit);

//     if (!rules.length) {
//       return res.json({
//         success: true,
//         message: "No bundles available. Run MBA first.",
//         data: [],
//       });
//     }

//     const bundles = rules.map((rule) => {
//       const products = [...rule.antecedent, ...rule.consequent];

//       let expectedUplift = "Medium";
//       if (rule.lift >= 3) expectedUplift = "Very High";
//       else if (rule.lift >= 2) expectedUplift = "High";
//       else if (rule.lift < 1) expectedUplift = "Low";

//       return {
//         products,
//         confidence: rule.confidence,
//         lift: rule.lift,
//         support: rule.support,
//         expectedUplift,
//       };
//     });

//     res.json({
//       success: true,
//       count: bundles.length,
//       data: bundles,
//     });
//   } catch (err) {
//     next(err);
//   }
// };
// controllers/recommendationController.js


exports.getProductBundles = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const limit = Number(req.query.limit || 20);

    const rules = await AssociationRule.find({ userId })
      .sort({ lift: -1 })
      .limit(limit)
      .lean();

    if (!rules.length) {
      return res.json({
        success: true,
        message: "No bundles available. Run MBA first.",
        data: [],
      });
    }

    // Build product map
    const products = await Product.find({ user: userId }).lean();
    const productMap = {};
    products.forEach((p) => {
      productMap[p.productId] = p;
    });

    const bundles = rules.map((rule) => {
      const productIds = [...rule.antecedent, ...rule.consequent];

      let expectedUplift = "Medium";
      if (rule.lift >= 3) expectedUplift = "Very High";
      else if (rule.lift >= 2) expectedUplift = "High";
      else if (rule.lift < 1) expectedUplift = "Low";

      const productsDetailed = productIds.map((pid) => {
        const p = productMap[pid];
        return {
          productId: pid,
          name: p?.name || pid,
        };
      });

      return {
        products: productsDetailed, // array of { productId, name }
        confidence: rule.confidence,
        lift: rule.lift,
        support: rule.support,
        expectedUplift,
      };
    });

    res.json({
      success: true,
      count: bundles.length,
      data: bundles,
    });
  } catch (err) {
    next(err);
  }
};

   


const Product = require("../models/Product");

exports.getInventoryOptimization = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const products = await Product.find({ user: userId }).lean();

    if (!products.length) {
      return res.json({
        success: true,
        message: "No products found for inventory optimization",
        data: [],
      });
    }

    // Very simple heuristic; expiry-aware logic is in Python side if you call it.
    const suggestions = products.map((p) => {
      const currentStock = p.stock || 0;
      let recommendedStock = 50;

      if (p.expiryDate) {
        const daysLeft =
          (new Date(p.expiryDate) - new Date()) / (1000 * 60 * 60 * 24);

        if (daysLeft <= 0) {
          recommendedStock = 0;
        } else if (daysLeft <= 3) {
          recommendedStock = Math.min(currentStock, 5);
        } else if (daysLeft <= 7) {
          recommendedStock = Math.min(currentStock, 10);
        }
      }

      let reason = "Stock level looks healthy";
      if (currentStock === 0) reason = "Out of stock ‚Äì consider restocking";
      else if (currentStock < recommendedStock)
        reason = "Low stock based on target level";
      else if (currentStock > recommendedStock * 2)
        reason = "Overstocked ‚Äì reduce future orders";

      return {
        productId: p.productId,
        currentStock,
        recommendedStock,
        reason,
      };
    });

    res.json({
      success: true,
      count: suggestions.length,
      data: suggestions,
    });
  } catch (err) {
    next(err);
  }
};




// controllers/recommendationController.js
exports.generateMBA = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const {
      minSupport = 0.01,
      minConfidence = 0.3,
      minLift = 1.0,
    } = req.body || {};

    const transactions = await Transaction.find({ user: userId }).lean();
console.log("MBA transactions count:", transactions.length);
    const mlRes = await axios.post("http://localhost:8000/ml/mba", {
      userId,                                  // üëà important
      transactions,
      params: { minSupport, minConfidence, minLift },
    });

    const rulesFromML = mlRes.data.rules || [];

    return res.json({
      success: true,
      data: {
        rules: rulesFromML,
      },
    });
  } catch (err) {
    next(err);
  }
};

