// // controllers/recommendationController.js

// const Transaction = require("../models/Transaction");

// const AssociationRule = require("../models/AssociationRule");
// const axios = require("axios");

// exports.getHybridRecommendations = async (req, res, next) => {
//   try {
//     const userId = req.user.id;
//     const limit = Number(req.query.limit || 10);

//     // 1Ô∏è‚É£ Fetch MBA rules (already generated by Python ML)
//     const rules = await AssociationRule.find({ userId })
//       .sort({ lift: -1 })
//       .limit(100);

//     if (rules.length === 0) {
//       return res.json({
//         success: true,
//         message: "No recommendations available. Run ML engine first.",
//         data: [],
//       });
//     }

//     // 2Ô∏è‚É£ Fetch all products of retailer
//     const products = await Product.find({ user: userId });

//     const productMap = {};
//     products.forEach((p) => {
//       productMap[p.name] = p;
//     });

//     const recommendations = [];

//     // 3Ô∏è‚É£ Build retailer-friendly recommendations
//     for (const rule of rules) {
//       const from = rule.antecedent[0];
//       const to = rule.consequent[0];

//       const fromProduct = productMap[from];
//       const toProduct = productMap[to];

//       if (!fromProduct || !toProduct) continue;

//       // 4Ô∏è‚É£ Expiry-aware logic (Step 3 support)
//       let urgency = "Normal Sale";
//       if (toProduct.expiryDate) {
//         const daysLeft =
//           (new Date(toProduct.expiryDate) - new Date()) /
//           (1000 * 60 * 60 * 24);

//         if (daysLeft <= 0) urgency = "Expired ‚Äì Remove from stock";
//         else if (daysLeft <= 3) urgency = "Urgent Sale (Near Expiry)";
//         else if (daysLeft <= 7) urgency = "Sell Soon";
//       }

//       recommendations.push({
//         buyWith: {
//           productId: fromProduct.productId,
//           productName: fromProduct.name,
//         },
//         recommend: {
//           productId: toProduct.productId,
//           productName: toProduct.name,
//         },
//         metrics: {
//           lift: rule.lift.toFixed(2),
//           confidence: rule.confidence.toFixed(2),
//           support: rule.support.toFixed(2),
//         },
//         reason: `Frequently bought together (${urgency})`,
//       });

//       if (recommendations.length >= limit) break;
//     }

//     return res.json({
//       success: true,
//       count: recommendations.length,
//       data: recommendations,
//     });
//   } catch (err) {
//     next(err);
//   }
// };

// // exports.getDashboard = async (req, res, next) => {
// //   try {
// //     const userId = req.user.id;

// //     const rules = await AssociationRule.find({ userId })
// //       .sort({ lift: -1 })
// //       .limit(20);

// //     const bundles = rules.map((rule) => ({
// //       products: [...rule.antecedent, ...rule.consequent],
// //       confidence: rule.confidence,
// //       lift: rule.lift,
// //       expectedUplift: "High",
// //     }));

// //     return res.json({
// //       success: true,
// //       data: {
// //         bundles,
// //       },
// //     });
// //   } catch (err) {
// //     next(err);
// //   }
// // };
// // controllers/recommendationController.js



// exports.getDashboard = async (req, res, next) => {
//   try {
//     const userId = req.user.id;

//     const rules = await AssociationRule.find({ userId })
//       .sort({ lift: -1 })
//       .limit(20)
//       .lean();

//     if (!rules.length) {
//       return res.json({
//         success: true,
//         data: { bundles: [] },
//       });
//     }

//     const products = await Product.find({ user: userId }).lean();
//     const productMap = {};
//     products.forEach((p) => {
//       productMap[p.productId] = p;
//     });

//     const bundles = rules.map((rule) => {
//       const productIds = [...rule.antecedent, ...rule.consequent];

//       const items = productIds.map((pid) => {
//         const p = productMap[pid];
//         return {
//           productId: pid,
//           name: p?.name || pid,
//           expiryDate: p?.expiryDate || null,
//           status: p?.status || "ACTIVE",
//         };
//       });

//       // Compute near expiry from expiryDate (e.g., within next 7 days)
//       const hasNearExpiry = items.some((it) => {
//         if (!it.expiryDate) return false;
//         const daysLeft =
//           (new Date(it.expiryDate) - new Date()) / (1000 * 60 * 60 * 24);
//         return daysLeft > 0 && daysLeft <= 7;
//       });

//       return {
//         products: items,
//         confidence: rule.confidence,
//         lift: rule.lift,
//         support: rule.support,
//         expectedUplift: "High",
//         metadata: {
//           nearExpiryInBundle: hasNearExpiry,
//         },
//       };
//     });

//     res.json({
//       success: true,
//       data: { bundles },
//     });
//   } catch (err) {
//     next(err);
//   }
// };


// /**
//  * =====================================================
//  * @desc    Get Raw Association Rules (optional table view)
//  * @route   GET /api/recommendations/rules
//  * =====================================================
//  */
// exports.getAssociationRules = async (req, res, next) => {
//   try {
//     const rules = await AssociationRule.find({ userId: req.user.id })
//       .sort({ lift: -1 })
//       .limit(50);

//     res.json({
//       success: true,
//       count: rules.length,
//       data: rules,
//     });
//   } catch (err) {
//     next(err);
//   }
// };






// exports.getProductBundles = async (req, res, next) => {
//   try {
//     const userId = req.user.id;
//     const limit = Number(req.query.limit || 20);

//     const rules = await AssociationRule.find({ userId })
//       .sort({ lift: -1 })
//       .limit(limit)
//       .lean();

//     if (!rules.length) {
//       return res.json({
//         success: true,
//         message: "No bundles available. Run MBA first.",
//         data: [],
//       });
//     }

//     // Build product map
//     const products = await Product.find({ user: userId }).lean();
//     const productMap = {};
//     products.forEach((p) => {
//       productMap[p.productId] = p;
//     });

//     const bundles = rules.map((rule) => {
//       const productIds = [...rule.antecedent, ...rule.consequent];

//       let expectedUplift = "Medium";
//       if (rule.lift >= 3) expectedUplift = "Very High";
//       else if (rule.lift >= 2) expectedUplift = "High";
//       else if (rule.lift < 1) expectedUplift = "Low";

//       const productsDetailed = productIds.map((pid) => {
//         const p = productMap[pid];
//         return {
//           productId: pid,
//           name: p?.name || pid,
//         };
//       });

//       return {
//         products: productsDetailed, // array of { productId, name }
//         confidence: rule.confidence,
//         lift: rule.lift,
//         support: rule.support,
//         expectedUplift,
//       };
//     });

//     res.json({
//       success: true,
//       count: bundles.length,
//       data: bundles,
//     });
//   } catch (err) {
//     next(err);
//   }
// };

   


// const Product = require("../models/Product");

// exports.getInventoryOptimization = async (req, res, next) => {
//   try {
//     const userId = req.user.id;
//     const products = await Product.find({ user: userId }).lean();

//     if (!products.length) {
//       return res.json({
//         success: true,
//         message: "No products found for inventory optimization",
//         data: [],
//       });
//     }

//     // Very simple heuristic; expiry-aware logic is in Python side if you call it.
//     const suggestions = products.map((p) => {
//       const currentStock = p.stock || 0;
//       let recommendedStock = 50;

//       if (p.expiryDate) {
//         const daysLeft =
//           (new Date(p.expiryDate) - new Date()) / (1000 * 60 * 60 * 24);

//         if (daysLeft <= 0) {
//           recommendedStock = 0;
//         } else if (daysLeft <= 3) {
//           recommendedStock = Math.min(currentStock, 5);
//         } else if (daysLeft <= 7) {
//           recommendedStock = Math.min(currentStock, 10);
//         }
//       }

//       let reason = "Stock level looks healthy";
//       if (currentStock === 0) reason = "Out of stock ‚Äì consider restocking";
//       else if (currentStock < recommendedStock)
//         reason = "Low stock based on target level";
//       else if (currentStock > recommendedStock * 2)
//         reason = "Overstocked ‚Äì reduce future orders";

//       return {
//         productId: p.productId,
//         currentStock,
//         recommendedStock,
//         reason,
//       };
//     });

//     res.json({
//       success: true,
//       count: suggestions.length,
//       data: suggestions,
//     });
//   } catch (err) {
//     next(err);
//   }
// };




// // controllers/recommendationController.js
// exports.generateMBA = async (req, res, next) => {
//   try {
//     const userId = req.user.id;
//     const {
//       minSupport = 0.01,
//       minConfidence = 0.3,
//       minLift = 1.0,
//     } = req.body || {};

//     const transactions = await Transaction.find({ user: userId }).lean();
// console.log("MBA transactions count:", transactions.length);
//     const mlRes = await axios.post("http://localhost:8000/ml/mba", {
//       userId,                                  // üëà important
//       transactions,
//       params: { minSupport, minConfidence, minLift },
//     });

//     const rulesFromML = mlRes.data.rules || [];

//     return res.json({
//       success: true,
//       data: {
//         rules: rulesFromML,
//       },
//     });
//   } catch (err) {
//     next(err);
//   }
// };

const axios = require("axios");
const AssociationRule = require("../models/AssociationRule");
const Product = require("../models/Product.js");
const Transaction = require("../models/Transaction");

const ML_ENGINE_URL = "http://127.0.0.1:8000";

/**
 * @desc    Triggers the Python Training Pipeline
 * @route   POST /api/recommendations/mba
 */
exports.generateMBA = async (req, res, next) => {
  try {
    const userId = req.user.id;
    // Calling your updated FastAPI training endpoint
    const mlRes = await axios.post(`${ML_ENGINE_URL}/api/train/${userId}`);

    res.json({
      success: true,
      message: "ML Engine training successful",
      data: mlRes.data,
    });
  } catch (err) {
    console.error("ML Training Error:", err.response?.data || err.message);
    res.status(500).json({
      success: false,
      error: "ML Engine failed to process training",
      details: err.response?.data?.detail || err.message,
    });
  }
};

/**
 * @desc    Fetch Hybrid Recommendations from Python Fusion Engine
 * @route   GET /api/recommendations/hybrid
 */
exports.getHybridRecommendations = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const mlRes = await axios.get(`${ML_ENGINE_URL}/api/recommend/${userId}`);

    res.json({
      success: true,
      count: mlRes.data.length,
      data: mlRes.data,
    });
  } catch (err) {
    next(err);
  }
};

/**
 * @desc    Fetch Bundles (Pre-calculated MBA rules mapped to Product Names)
 * @route   GET /api/recommendations/bundles
 */
exports.getProductBundles = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const rules = await AssociationRule.find({ userId }).sort({ lift: -1 }).limit(20).lean();

    if (!rules.length) {
      return res.json({ success: true, message: "No bundles found. Train ML first.", data: [] });
    }

    const products = await Product.find({ user: userId }).lean();
    const productMap = {};
    products.forEach((p) => { productMap[p.productId] = p; });

    const bundles = rules.map((rule) => {
      // --- FIXED: Changed to plural 'antecedents' and 'consequents' ---
      // We also add || [] as a safety net to prevent 'not iterable' errors
      const antecedentList = rule.antecedents || [];
      const consequentList = rule.consequents || [];

      return {
        bundleId: rule._id,
        items: [...antecedentList, ...consequentList].map((pid) => ({
          productId: pid,
          name: productMap[pid]?.name || `Product ${pid}`,
          image: productMap[pid]?.image || null, // Helpful for the UI
        })),
        // Formatting metrics for the frontend
        confidence: (rule.confidence || 0).toFixed(2),
        lift: (rule.lift || 0).toFixed(2),
        support: (rule.support || 0).toFixed(2),
        uplift: rule.lift > 2 ? "High" : "Medium",
      };
    });

    res.json({ success: true, data: bundles });
  } catch (err) {
    // This will now catch and pass errors to your errorHandler.js correctly
    next(err);
  }
};

/**
 * @desc    Get Inventory Optimization Suggestions
 * @route   POST /api/recommendations/inventory
 */
exports.getInventoryOptimization = async (req, res, next) => {
  try {
    const products = await Product.find({ user: req.user.id }).lean();

    const suggestions = products.map((p) => ({
      productId: p.productId,
      name: p.name,
      currentStock: p.stock,
      needsRestock: p.stock < 10, // Highlight this on UI
      priority: p.stock < 3 ? "CRITICAL" : (p.stock < 10 ? "WARNING" : "OK"),
      suggestion: p.stock < 10 ? "Restock Now" : "Sufficient"
    }));

    res.json({ success: true, data: suggestions });
  } catch (err) {
    next(err);
  }
};

/**
 * @desc    Dashboard Summary
 */

exports.getDashboard = async (req, res, next) => {
  try {
    const userId = req.user?._id || req.user?.id;
    if (!userId) {
      return res.status(401).json({ success: false, message: "User not authenticated" });
    }

    // 1. Basic Stats
    const ruleCount = await AssociationRule.countDocuments({ userId });
    const productCount = await Product.countDocuments({ user: userId });

    // 2. Fetch Near Expiry Data (Paneer wala logic)
    // Maan lo hum 7 din ka buffer le rahe hain
    const sevenDaysFromNow = new Date();
    sevenDaysFromNow.setDate(sevenDaysFromNow.getDate() + 7);

    const nearExpiry = await Product.find({
      user: userId,
      expiryDate: { $lte: sevenDaysFromNow, $gte: new Date() }
    }).limit(5).lean(); // Top 5 alerts kaafi hain dashboard ke liye

    // 3. Fetch Top Bundles
// Dashboard controller mein bundles fetch karte waqt
const bundles = await AssociationRule.find({ userId })
  .sort({ lift: -1, confidence: -1 })
  .limit(3)
  .populate({
    path: 'products.productId',
    options: { strictPopulate: false } // Yeh error ko bypass kar dega
  })
  .lean();// .populate() ko delete kar dein

    // FINAL RESPONSE
    res.json({
      success: true,
      data: {
        totalRules: ruleCount,
        totalProducts: productCount,
        engineStatus: "Active",
        near_expiry: nearExpiry, // Ab Paneer frontend tak pahunchega
        bundles: bundles
      },
    });
  } catch (err) {
    next(err);
  }
};

/**
 * @desc    Raw Association Rules for Table View
 */
exports.getAssociationRules = async (req, res, next) => {
  try {
    const rules = await AssociationRule.find({ userId: req.user.id }).sort({ lift: -1 });
    res.json({ success: true, data: rules });
  } catch (err) {
    next(err);
  }
};